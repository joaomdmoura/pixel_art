{"version":3,"sources":["web/static/vendor/phoenix.js","web/static/js/app.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;uBC7oCqB,SAAS;;IAExB,GAAG;WAAH,GAAG;0BAAH,GAAG;;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","file":"priv/static/js/app.js","sourcesContent":["(function(/*! Brunch !*/) {\n  'use strict';\n\n  var globals = typeof window !== 'undefined' ? window : global;\n  if (typeof globals.require === 'function') return;\n\n  var modules = {};\n  var cache = {};\n\n  var has = function(object, name) {\n    return ({}).hasOwnProperty.call(object, name);\n  };\n\n  var expand = function(root, name) {\n    var results = [], parts, part;\n    if (/^\\.\\.?(\\/|$)/.test(name)) {\n      parts = [root, name].join('/').split('/');\n    } else {\n      parts = name.split('/');\n    }\n    for (var i = 0, length = parts.length; i < length; i++) {\n      part = parts[i];\n      if (part === '..') {\n        results.pop();\n      } else if (part !== '.' && part !== '') {\n        results.push(part);\n      }\n    }\n    return results.join('/');\n  };\n\n  var dirname = function(path) {\n    return path.split('/').slice(0, -1).join('/');\n  };\n\n  var localRequire = function(path) {\n    return function(name) {\n      var dir = dirname(path);\n      var absolute = expand(dir, name);\n      return globals.require(absolute, path);\n    };\n  };\n\n  var initModule = function(name, definition) {\n    var module = {id: name, exports: {}};\n    cache[name] = module;\n    definition(module.exports, localRequire(name), module);\n    return module.exports;\n  };\n\n  var require = function(name, loaderPath) {\n    var path = expand(name, '.');\n    if (loaderPath == null) loaderPath = '/';\n\n    if (has(cache, path)) return cache[path].exports;\n    if (has(modules, path)) return initModule(path, modules[path]);\n\n    var dirIndex = expand(path, './index');\n    if (has(cache, dirIndex)) return cache[dirIndex].exports;\n    if (has(modules, dirIndex)) return initModule(dirIndex, modules[dirIndex]);\n\n    throw new Error('Cannot find module \"' + name + '\" from '+ '\"' + loaderPath + '\"');\n  };\n\n  var define = function(bundle, fn) {\n    if (typeof bundle === 'object') {\n      for (var key in bundle) {\n        if (has(bundle, key)) {\n          modules[key] = bundle[key];\n        }\n      }\n    } else {\n      modules[bundle] = fn;\n    }\n  };\n\n  var list = function() {\n    var result = [];\n    for (var item in modules) {\n      if (has(modules, item)) {\n        result.push(item);\n      }\n    }\n    return result;\n  };\n\n  globals.require = require;\n  globals.require.define = define;\n  globals.require.register = define;\n  globals.require.list = list;\n  globals.require.brunch = true;\n})();\nrequire.define({'phoenix': function(exports, require, module){ \"use strict\";\n\nvar _prototypeProperties = function (child, staticProps, instanceProps) { if (staticProps) Object.defineProperties(child, staticProps); if (instanceProps) Object.defineProperties(child.prototype, instanceProps); };\n\nvar _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } };\n\n// Phoenix Channels JavaScript client\n//\n// ## Socket Connection\n//\n// A single connection is established to the server and\n// channels are mulitplexed over the connection.\n// Connect to the server using the `Socket` class:\n//\n//     let socket = new Socket(\"/ws\")\n//     socket.connect()\n//\n// The `Socket` constructor takes the mount point of the socket\n// as well as options that can be found in the Socket docs,\n// such as configuring the `LongPoller` transport, and heartbeat.\n// Socket params can also be passed as an option for default, but\n// overridable channel params to apply to all channels.\n//\n//\n// ## Channels\n//\n// Channels are isolated, concurrent processes on the server that\n// subscribe to topics and broker events between the client and server.\n// To join a channel, you must provide the topic, and channel params for\n// authorization. Here's an example chat room example where `\"new_msg\"`\n// events are listened for, messages are pushed to the server, and\n// the channel is joined with ok/error matches, and `after` hook:\n//\n//     let chan = socket.chan(\"rooms:123\", {token: roomToken})\n//     chan.on(\"new_msg\", msg => console.log(\"Got message\", msg) )\n//     $input.onEnter( e => {\n//       chan.push(\"new_msg\", {body: e.target.val})\n//           .receive(\"ok\", (message) => console.log(\"created message\", message) )\n//           .receive(\"error\", (reasons) => console.log(\"create failed\", reasons) )\n//           .after(10000, () => console.log(\"Networking issue. Still waiting...\") )\n//     })\n//     chan.join()\n//         .receive(\"ok\", ({messages}) => console.log(\"catching up\", messages) )\n//         .receive(\"error\", ({reason}) => console.log(\"failed join\", reason) )\n//         .after(10000, () => console.log(\"Networking issue. Still waiting...\") )\n//\n//\n// ## Joining\n//\n// Joining a channel with `chan.join(topic, params)`, binds the params to\n// `chan.params`. Subsequent rejoins will send up the modified params for\n// updating authorization params, or passing up last_message_id information.\n// Successful joins receive an \"ok\" status, while unsuccessful joins\n// receive \"error\".\n//\n//\n// ## Pushing Messages\n//\n// From the previous example, we can see that pushing messages to the server\n// can be done with `chan.push(eventName, payload)` and we can optionally\n// receive responses from the push. Additionally, we can use\n// `after(millsec, callback)` to abort waiting for our `receive` hooks and\n// take action after some period of waiting.\n//\n//\n// ## Socket Hooks\n//\n// Lifecycle events of the multiplexed connection can be hooked into via\n// `socket.onError()` and `socket.onClose()` events, ie:\n//\n//     socket.onError( () => console.log(\"there was an error with the connection!\") )\n//     socket.onClose( () => console.log(\"the connection dropped\") )\n//\n//\n// ## Channel Hooks\n//\n// For each joined channel, you can bind to `onError` and `onClose` events\n// to monitor the channel lifecycle, ie:\n//\n//     chan.onError( () => console.log(\"there was an error!\") )\n//     chan.onClose( () => console.log(\"the channel has gone away gracefully\") )\n//\n// ### onError hooks\n//\n// `onError` hooks are invoked if the socket connection drops, or the channel\n// crashes on the server. In either case, a channel rejoin is attemtped\n// automatically in an exponential backoff manner.\n//\n// ### onClose hooks\n//\n// `onClose` hooks are invoked only in two cases. 1) the channel explicitly\n// closed on the server, or 2). The client explicitly closed, by calling\n// `chan.leave()`\n//\n\nvar SOCKET_STATES = { connecting: 0, open: 1, closing: 2, closed: 3 };\nvar CHAN_STATES = {\n  closed: \"closed\",\n  errored: \"errored\",\n  joined: \"joined\",\n  joining: \"joining\" };\nvar CHAN_EVENTS = {\n  close: \"phx_close\",\n  error: \"phx_error\",\n  join: \"phx_join\",\n  reply: \"phx_reply\",\n  leave: \"phx_leave\"\n};\n\nvar Push = (function () {\n\n  // Initializes the Push\n  //\n  // chan - The Channel\n  // event - The event, ie `\"phx_join\"`\n  // payload - The payload, ie `{user_id: 123}`\n  //\n\n  function Push(chan, event, payload) {\n    _classCallCheck(this, Push);\n\n    this.chan = chan;\n    this.event = event;\n    this.payload = payload || {};\n    this.receivedResp = null;\n    this.afterHook = null;\n    this.recHooks = [];\n    this.sent = false;\n  }\n\n  _prototypeProperties(Push, null, {\n    send: {\n      value: function send() {\n        var _this = this;\n\n        var ref = this.chan.socket.makeRef();\n        this.refEvent = this.chan.replyEventName(ref);\n        this.receivedResp = null;\n        this.sent = false;\n\n        this.chan.on(this.refEvent, function (payload) {\n          _this.receivedResp = payload;\n          _this.matchReceive(payload);\n          _this.cancelRefEvent();\n          _this.cancelAfter();\n        });\n\n        this.startAfter();\n        this.sent = true;\n        this.chan.socket.push({\n          topic: this.chan.topic,\n          event: this.event,\n          payload: this.payload,\n          ref: ref\n        });\n      },\n      writable: true,\n      configurable: true\n    },\n    receive: {\n      value: function receive(status, callback) {\n        if (this.receivedResp && this.receivedResp.status === status) {\n          callback(this.receivedResp.response);\n        }\n\n        this.recHooks.push({ status: status, callback: callback });\n        return this;\n      },\n      writable: true,\n      configurable: true\n    },\n    after: {\n      value: function after(ms, callback) {\n        if (this.afterHook) {\n          throw \"only a single after hook can be applied to a push\";\n        }\n        var timer = null;\n        if (this.sent) {\n          timer = setTimeout(callback, ms);\n        }\n        this.afterHook = { ms: ms, callback: callback, timer: timer };\n        return this;\n      },\n      writable: true,\n      configurable: true\n    },\n    matchReceive: {\n\n      // private\n\n      value: function matchReceive(_ref) {\n        var status = _ref.status;\n        var response = _ref.response;\n        var ref = _ref.ref;\n\n        this.recHooks.filter(function (h) {\n          return h.status === status;\n        }).forEach(function (h) {\n          return h.callback(response);\n        });\n      },\n      writable: true,\n      configurable: true\n    },\n    cancelRefEvent: {\n      value: function cancelRefEvent() {\n        this.chan.off(this.refEvent);\n      },\n      writable: true,\n      configurable: true\n    },\n    cancelAfter: {\n      value: function cancelAfter() {\n        if (!this.afterHook) {\n          return;\n        }\n        clearTimeout(this.afterHook.timer);\n        this.afterHook.timer = null;\n      },\n      writable: true,\n      configurable: true\n    },\n    startAfter: {\n      value: function startAfter() {\n        var _this = this;\n\n        if (!this.afterHook) {\n          return;\n        }\n        var callback = function () {\n          _this.cancelRefEvent();\n          _this.afterHook.callback();\n        };\n        this.afterHook.timer = setTimeout(callback, this.afterHook.ms);\n      },\n      writable: true,\n      configurable: true\n    }\n  });\n\n  return Push;\n})();\n\nvar Channel = exports.Channel = (function () {\n  function Channel(topic, params, socket) {\n    var _this = this;\n\n    _classCallCheck(this, Channel);\n\n    this.state = CHAN_STATES.closed;\n    this.topic = topic;\n    this.params = params || {};\n    this.socket = socket;\n    this.bindings = [];\n    this.joinedOnce = false;\n    this.joinPush = new Push(this, CHAN_EVENTS.join, this.params);\n    this.pushBuffer = [];\n    this.rejoinTimer = new Timer(function () {\n      return _this.rejoinUntilConnected();\n    }, this.socket.reconnectAfterMs);\n    this.joinPush.receive(\"ok\", function () {\n      _this.state = CHAN_STATES.joined;\n      _this.rejoinTimer.reset();\n    });\n    this.onClose(function () {\n      _this.socket.log(\"channel\", \"close \" + _this.topic);\n      _this.state = CHAN_STATES.closed;\n      _this.socket.remove(_this);\n    });\n    this.onError(function (reason) {\n      _this.socket.log(\"channel\", \"error \" + _this.topic, reason);\n      _this.state = CHAN_STATES.errored;\n      _this.rejoinTimer.setTimeout();\n    });\n    this.on(CHAN_EVENTS.reply, function (payload, ref) {\n      _this.trigger(_this.replyEventName(ref), payload);\n    });\n  }\n\n  _prototypeProperties(Channel, null, {\n    rejoinUntilConnected: {\n      value: function rejoinUntilConnected() {\n        this.rejoinTimer.setTimeout();\n        if (this.socket.isConnected()) {\n          this.rejoin();\n        }\n      },\n      writable: true,\n      configurable: true\n    },\n    join: {\n      value: function join() {\n        if (this.joinedOnce) {\n          throw \"tried to join multiple times. 'join' can only be called a single time per channel instance\";\n        } else {\n          this.joinedOnce = true;\n        }\n        this.sendJoin();\n        return this.joinPush;\n      },\n      writable: true,\n      configurable: true\n    },\n    onClose: {\n      value: function onClose(callback) {\n        this.on(CHAN_EVENTS.close, callback);\n      },\n      writable: true,\n      configurable: true\n    },\n    onError: {\n      value: function onError(callback) {\n        this.on(CHAN_EVENTS.error, function (reason) {\n          return callback(reason);\n        });\n      },\n      writable: true,\n      configurable: true\n    },\n    on: {\n      value: function on(event, callback) {\n        this.bindings.push({ event: event, callback: callback });\n      },\n      writable: true,\n      configurable: true\n    },\n    off: {\n      value: function off(event) {\n        this.bindings = this.bindings.filter(function (bind) {\n          return bind.event !== event;\n        });\n      },\n      writable: true,\n      configurable: true\n    },\n    canPush: {\n      value: function canPush() {\n        return this.socket.isConnected() && this.state === CHAN_STATES.joined;\n      },\n      writable: true,\n      configurable: true\n    },\n    push: {\n      value: function push(event, payload) {\n        if (!this.joinedOnce) {\n          throw \"tried to push '\" + event + \"' to '\" + this.topic + \"' before joining. Use chan.join() before pushing events\";\n        }\n        var pushEvent = new Push(this, event, payload);\n        if (this.canPush()) {\n          pushEvent.send();\n        } else {\n          this.pushBuffer.push(pushEvent);\n        }\n\n        return pushEvent;\n      },\n      writable: true,\n      configurable: true\n    },\n    leave: {\n\n      // Leaves the channel\n      //\n      // Unsubscribes from server events, and\n      // instructs channel to terminate on server\n      //\n      // Triggers onClose() hooks\n      //\n      // To receive leave acknowledgements, use the a `receive`\n      // hook to bind to the server ack, ie:\n      //\n      //     chan.leave().receive(\"ok\", () => alert(\"left!\") )\n      //\n\n      value: function leave() {\n        var _this = this;\n\n        return this.push(CHAN_EVENTS.leave).receive(\"ok\", function () {\n          _this.log(\"channel\", \"leave \" + _this.topic);\n          _this.trigger(CHAN_EVENTS.close, \"leave\");\n        });\n      },\n      writable: true,\n      configurable: true\n    },\n    onMessage: {\n\n      // Overridable message hook\n      //\n      // Receives all events for specialized message handling\n\n      value: function onMessage(event, payload, ref) {},\n      writable: true,\n      configurable: true\n    },\n    isMember: {\n\n      // private\n\n      value: function isMember(topic) {\n        return this.topic === topic;\n      },\n      writable: true,\n      configurable: true\n    },\n    sendJoin: {\n      value: function sendJoin() {\n        this.state = CHAN_STATES.joining;\n        this.joinPush.send();\n      },\n      writable: true,\n      configurable: true\n    },\n    rejoin: {\n      value: function rejoin() {\n        this.sendJoin();\n        this.pushBuffer.forEach(function (pushEvent) {\n          return pushEvent.send();\n        });\n        this.pushBuffer = [];\n      },\n      writable: true,\n      configurable: true\n    },\n    trigger: {\n      value: function trigger(triggerEvent, payload, ref) {\n        this.onMessage(triggerEvent, payload, ref);\n        this.bindings.filter(function (bind) {\n          return bind.event === triggerEvent;\n        }).map(function (bind) {\n          return bind.callback(payload, ref);\n        });\n      },\n      writable: true,\n      configurable: true\n    },\n    replyEventName: {\n      value: function replyEventName(ref) {\n        return \"chan_reply_\" + ref;\n      },\n      writable: true,\n      configurable: true\n    }\n  });\n\n  return Channel;\n})();\n\nvar Socket = exports.Socket = (function () {\n\n  // Initializes the Socket\n  //\n  // endPoint - The string WebSocket endpoint, ie, \"ws://example.com/ws\",\n  //                                               \"wss://example.com\"\n  //                                               \"/ws\" (inherited host & protocol)\n  // opts - Optional configuration\n  //   transport - The Websocket Transport, ie WebSocket, Phoenix.LongPoller.\n  //               Defaults to WebSocket with automatic LongPoller fallback.\n  //   params - The defaults for all channel params, ie `{user_id: userToken}`\n  //   heartbeatIntervalMs - The millisec interval to send a heartbeat message\n  //   reconnectAfterMs - The optional function that returns the millsec\n  //                      reconnect interval. Defaults to stepped backoff of:\n  //\n  //     function(tries){\n  //       return [1000, 5000, 10000][tries - 1] || 10000\n  //     }\n  //\n  //   logger - The optional function for specialized logging, ie:\n  //     `logger: (kind, msg, data) => { console.log(`${kind}: ${msg}`, data) }\n  //\n  //   longpollerTimeout - The maximum timeout of a long poll AJAX request.\n  //                        Defaults to 20s (double the server long poll timer).\n  //\n  // For IE8 support use an ES5-shim (https://github.com/es-shims/es5-shim)\n  //\n\n  function Socket(endPoint) {\n    var _this = this;\n\n    var opts = arguments[1] === undefined ? {} : arguments[1];\n\n    _classCallCheck(this, Socket);\n\n    this.stateChangeCallbacks = { open: [], close: [], error: [], message: [] };\n    this.channels = [];\n    this.sendBuffer = [];\n    this.ref = 0;\n    this.transport = opts.transport || window.WebSocket || LongPoller;\n    this.heartbeatIntervalMs = opts.heartbeatIntervalMs || 30000;\n    this.reconnectAfterMs = opts.reconnectAfterMs || function (tries) {\n      return [1000, 5000, 10000][tries - 1] || 10000;\n    };\n    this.reconnectTimer = new Timer(function () {\n      return _this.connect();\n    }, this.reconnectAfterMs);\n    this.logger = opts.logger || function () {}; // noop\n    this.longpollerTimeout = opts.longpollerTimeout || 20000;\n    this.endPoint = this.expandEndpoint(endPoint);\n    this.params = opts.params || {};\n  }\n\n  _prototypeProperties(Socket, null, {\n    protocol: {\n      value: function protocol() {\n        return location.protocol.match(/^https/) ? \"wss\" : \"ws\";\n      },\n      writable: true,\n      configurable: true\n    },\n    expandEndpoint: {\n      value: function expandEndpoint(endPoint) {\n        if (endPoint.charAt(0) !== \"/\") {\n          return endPoint;\n        }\n        if (endPoint.charAt(1) === \"/\") {\n          return \"\" + this.protocol() + \":\" + endPoint;\n        }\n\n        return \"\" + this.protocol() + \"://\" + location.host + \"\" + endPoint;\n      },\n      writable: true,\n      configurable: true\n    },\n    disconnect: {\n      value: function disconnect(callback, code, reason) {\n        if (this.conn) {\n          this.conn.onclose = function () {}; // noop\n          if (code) {\n            this.conn.close(code, reason || \"\");\n          } else {\n            this.conn.close();\n          }\n          this.conn = null;\n        }\n        callback && callback();\n      },\n      writable: true,\n      configurable: true\n    },\n    connect: {\n      value: function connect() {\n        var _this = this;\n\n        this.disconnect(function () {\n          _this.conn = new _this.transport(_this.endPoint);\n          _this.conn.timeout = _this.longpollerTimeout;\n          _this.conn.onopen = function () {\n            return _this.onConnOpen();\n          };\n          _this.conn.onerror = function (error) {\n            return _this.onConnError(error);\n          };\n          _this.conn.onmessage = function (event) {\n            return _this.onConnMessage(event);\n          };\n          _this.conn.onclose = function (event) {\n            return _this.onConnClose(event);\n          };\n        });\n      },\n      writable: true,\n      configurable: true\n    },\n    log: {\n\n      // Logs the message. Override `this.logger` for specialized logging. noops by default\n\n      value: function log(kind, msg, data) {\n        this.logger(kind, msg, data);\n      },\n      writable: true,\n      configurable: true\n    },\n    onOpen: {\n\n      // Registers callbacks for connection state change events\n      //\n      // Examples\n      //\n      //    socket.onError(function(error){ alert(\"An error occurred\") })\n      //\n\n      value: function onOpen(callback) {\n        this.stateChangeCallbacks.open.push(callback);\n      },\n      writable: true,\n      configurable: true\n    },\n    onClose: {\n      value: function onClose(callback) {\n        this.stateChangeCallbacks.close.push(callback);\n      },\n      writable: true,\n      configurable: true\n    },\n    onError: {\n      value: function onError(callback) {\n        this.stateChangeCallbacks.error.push(callback);\n      },\n      writable: true,\n      configurable: true\n    },\n    onMessage: {\n      value: function onMessage(callback) {\n        this.stateChangeCallbacks.message.push(callback);\n      },\n      writable: true,\n      configurable: true\n    },\n    onConnOpen: {\n      value: function onConnOpen() {\n        var _this = this;\n\n        this.log(\"transport\", \"connected to \" + this.endPoint, this.transport);\n        this.flushSendBuffer();\n        this.reconnectTimer.reset();\n        if (!this.conn.skipHeartbeat) {\n          clearInterval(this.heartbeatTimer);\n          this.heartbeatTimer = setInterval(function () {\n            return _this.sendHeartbeat();\n          }, this.heartbeatIntervalMs);\n        }\n        this.stateChangeCallbacks.open.forEach(function (callback) {\n          return callback();\n        });\n      },\n      writable: true,\n      configurable: true\n    },\n    onConnClose: {\n      value: function onConnClose(event) {\n        this.log(\"transport\", \"close\", event);\n        this.triggerChanError();\n        clearInterval(this.heartbeatTimer);\n        this.reconnectTimer.setTimeout();\n        this.stateChangeCallbacks.close.forEach(function (callback) {\n          return callback(event);\n        });\n      },\n      writable: true,\n      configurable: true\n    },\n    onConnError: {\n      value: function onConnError(error) {\n        this.log(\"transport\", error);\n        this.triggerChanError();\n        this.stateChangeCallbacks.error.forEach(function (callback) {\n          return callback(error);\n        });\n      },\n      writable: true,\n      configurable: true\n    },\n    triggerChanError: {\n      value: function triggerChanError() {\n        this.channels.forEach(function (chan) {\n          return chan.trigger(CHAN_EVENTS.error);\n        });\n      },\n      writable: true,\n      configurable: true\n    },\n    connectionState: {\n      value: function connectionState() {\n        switch (this.conn && this.conn.readyState) {\n          case SOCKET_STATES.connecting:\n            return \"connecting\";\n          case SOCKET_STATES.open:\n            return \"open\";\n          case SOCKET_STATES.closing:\n            return \"closing\";\n          default:\n            return \"closed\";\n        }\n      },\n      writable: true,\n      configurable: true\n    },\n    isConnected: {\n      value: function isConnected() {\n        return this.connectionState() === \"open\";\n      },\n      writable: true,\n      configurable: true\n    },\n    remove: {\n      value: function remove(chan) {\n        this.channels = this.channels.filter(function (c) {\n          return !c.isMember(chan.topic);\n        });\n      },\n      writable: true,\n      configurable: true\n    },\n    chan: {\n      value: function chan(topic) {\n        var chanParams = arguments[1] === undefined ? {} : arguments[1];\n\n        var mergedParams = {};\n        for (var key in this.params) {\n          mergedParams[key] = this.params[key];\n        }\n        for (var key in chanParams) {\n          mergedParams[key] = chanParams[key];\n        }\n\n        var chan = new Channel(topic, mergedParams, this);\n        this.channels.push(chan);\n        return chan;\n      },\n      writable: true,\n      configurable: true\n    },\n    push: {\n      value: function push(data) {\n        var _this = this;\n\n        var topic = data.topic;\n        var event = data.event;\n        var payload = data.payload;\n        var ref = data.ref;\n\n        var callback = function () {\n          return _this.conn.send(JSON.stringify(data));\n        };\n        this.log(\"push\", \"\" + topic + \" \" + event + \" (\" + ref + \")\", payload);\n        if (this.isConnected()) {\n          callback();\n        } else {\n          this.sendBuffer.push(callback);\n        }\n      },\n      writable: true,\n      configurable: true\n    },\n    makeRef: {\n\n      // Return the next message ref, accounting for overflows\n\n      value: function makeRef() {\n        var newRef = this.ref + 1;\n        if (newRef === this.ref) {\n          this.ref = 0;\n        } else {\n          this.ref = newRef;\n        }\n\n        return this.ref.toString();\n      },\n      writable: true,\n      configurable: true\n    },\n    sendHeartbeat: {\n      value: function sendHeartbeat() {\n        this.push({ topic: \"phoenix\", event: \"heartbeat\", payload: {}, ref: this.makeRef() });\n      },\n      writable: true,\n      configurable: true\n    },\n    flushSendBuffer: {\n      value: function flushSendBuffer() {\n        if (this.isConnected() && this.sendBuffer.length > 0) {\n          this.sendBuffer.forEach(function (callback) {\n            return callback();\n          });\n          this.sendBuffer = [];\n        }\n      },\n      writable: true,\n      configurable: true\n    },\n    onConnMessage: {\n      value: function onConnMessage(rawMessage) {\n        var msg = JSON.parse(rawMessage.data);\n        var topic = msg.topic;\n        var event = msg.event;\n        var payload = msg.payload;\n        var ref = msg.ref;\n\n        this.log(\"receive\", \"\" + (payload.status || \"\") + \" \" + topic + \" \" + event + \" \" + (ref && \"(\" + ref + \")\" || \"\"), payload);\n        this.channels.filter(function (chan) {\n          return chan.isMember(topic);\n        }).forEach(function (chan) {\n          return chan.trigger(event, payload, ref);\n        });\n        this.stateChangeCallbacks.message.forEach(function (callback) {\n          return callback(msg);\n        });\n      },\n      writable: true,\n      configurable: true\n    }\n  });\n\n  return Socket;\n})();\n\nvar LongPoller = exports.LongPoller = (function () {\n  function LongPoller(endPoint) {\n    _classCallCheck(this, LongPoller);\n\n    this.endPoint = null;\n    this.token = null;\n    this.sig = null;\n    this.skipHeartbeat = true;\n    this.onopen = function () {}; // noop\n    this.onerror = function () {}; // noop\n    this.onmessage = function () {}; // noop\n    this.onclose = function () {}; // noop\n    this.upgradeEndpoint = this.normalizeEndpoint(endPoint);\n    this.pollEndpoint = this.upgradeEndpoint + (/\\/$/.test(endPoint) ? \"poll\" : \"/poll\");\n    this.readyState = SOCKET_STATES.connecting;\n\n    this.poll();\n  }\n\n  _prototypeProperties(LongPoller, null, {\n    normalizeEndpoint: {\n      value: function normalizeEndpoint(endPoint) {\n        return endPoint.replace(\"ws://\", \"http://\").replace(\"wss://\", \"https://\");\n      },\n      writable: true,\n      configurable: true\n    },\n    endpointURL: {\n      value: function endpointURL() {\n        return this.pollEndpoint + (\"?token=\" + encodeURIComponent(this.token) + \"&sig=\" + encodeURIComponent(this.sig) + \"&format=json\");\n      },\n      writable: true,\n      configurable: true\n    },\n    closeAndRetry: {\n      value: function closeAndRetry() {\n        this.close();\n        this.readyState = SOCKET_STATES.connecting;\n      },\n      writable: true,\n      configurable: true\n    },\n    ontimeout: {\n      value: function ontimeout() {\n        this.onerror(\"timeout\");\n        this.closeAndRetry();\n      },\n      writable: true,\n      configurable: true\n    },\n    poll: {\n      value: function poll() {\n        var _this = this;\n\n        if (!(this.readyState === SOCKET_STATES.open || this.readyState === SOCKET_STATES.connecting)) {\n          return;\n        }\n\n        Ajax.request(\"GET\", this.endpointURL(), \"application/json\", null, this.timeout, this.ontimeout.bind(this), function (resp) {\n          if (resp) {\n            var status = resp.status;\n            var token = resp.token;\n            var sig = resp.sig;\n            var messages = resp.messages;\n\n            _this.token = token;\n            _this.sig = sig;\n          } else {\n            var status = 0;\n          }\n\n          switch (status) {\n            case 200:\n              messages.forEach(function (msg) {\n                return _this.onmessage({ data: JSON.stringify(msg) });\n              });\n              _this.poll();\n              break;\n            case 204:\n              _this.poll();\n              break;\n            case 410:\n              _this.readyState = SOCKET_STATES.open;\n              _this.onopen();\n              _this.poll();\n              break;\n            case 0:\n            case 500:\n              _this.onerror();\n              _this.closeAndRetry();\n              break;\n            default:\n              throw \"unhandled poll status \" + status;\n          }\n        });\n      },\n      writable: true,\n      configurable: true\n    },\n    send: {\n      value: function send(body) {\n        var _this = this;\n\n        Ajax.request(\"POST\", this.endpointURL(), \"application/json\", body, this.timeout, this.onerror.bind(this, \"timeout\"), function (resp) {\n          if (!resp || resp.status !== 200) {\n            _this.onerror(status);\n            _this.closeAndRetry();\n          }\n        });\n      },\n      writable: true,\n      configurable: true\n    },\n    close: {\n      value: function close(code, reason) {\n        this.readyState = SOCKET_STATES.closed;\n        this.onclose();\n      },\n      writable: true,\n      configurable: true\n    }\n  });\n\n  return LongPoller;\n})();\n\nvar Ajax = exports.Ajax = (function () {\n  function Ajax() {\n    _classCallCheck(this, Ajax);\n  }\n\n  _prototypeProperties(Ajax, {\n    request: {\n      value: function request(method, endPoint, accept, body, timeout, ontimeout, callback) {\n        if (window.XDomainRequest) {\n          var req = new XDomainRequest(); // IE8, IE9\n          this.xdomainRequest(req, method, endPoint, body, timeout, ontimeout, callback);\n        } else {\n          var req = window.XMLHttpRequest ? new XMLHttpRequest() : // IE7+, Firefox, Chrome, Opera, Safari\n          new ActiveXObject(\"Microsoft.XMLHTTP\"); // IE6, IE5\n          this.xhrRequest(req, method, endPoint, accept, body, timeout, ontimeout, callback);\n        }\n      },\n      writable: true,\n      configurable: true\n    },\n    xdomainRequest: {\n      value: function xdomainRequest(req, method, endPoint, body, timeout, ontimeout, callback) {\n        var _this = this;\n\n        req.timeout = timeout;\n        req.open(method, endPoint);\n        req.onload = function () {\n          var response = _this.parseJSON(req.responseText);\n          callback && callback(response);\n        };\n        if (ontimeout) {\n          req.ontimeout = ontimeout;\n        }\n\n        // Work around bug in IE9 that requires an attached onprogress handler\n        req.onprogress = function () {};\n\n        req.send(body);\n      },\n      writable: true,\n      configurable: true\n    },\n    xhrRequest: {\n      value: function xhrRequest(req, method, endPoint, accept, body, timeout, ontimeout, callback) {\n        var _this = this;\n\n        req.timeout = timeout;\n        req.open(method, endPoint, true);\n        req.setRequestHeader(\"Content-Type\", accept);\n        req.onerror = function () {\n          callback && callback(null);\n        };\n        req.onreadystatechange = function () {\n          if (req.readyState === _this.states.complete && callback) {\n            var response = _this.parseJSON(req.responseText);\n            callback(response);\n          }\n        };\n        if (ontimeout) {\n          req.ontimeout = ontimeout;\n        }\n\n        req.send(body);\n      },\n      writable: true,\n      configurable: true\n    },\n    parseJSON: {\n      value: function parseJSON(resp) {\n        return resp && resp !== \"\" ? JSON.parse(resp) : null;\n      },\n      writable: true,\n      configurable: true\n    }\n  });\n\n  return Ajax;\n})();\n\nAjax.states = { complete: 4 };\n\n// Creates a timer that accepts a `timerCalc` function to perform\n// calculated timeout retries, such as exponential backoff.\n//\n// ## Examples\n//\n//    let reconnectTimer = new Timer(() => this.connect(), function(tries){\n//      return [1000, 5000, 10000][tries - 1] || 10000\n//    })\n//    reconnectTimer.setTimeout() // fires after 1000\n//    reconnectTimer.setTimeout() // fires after 5000\n//    reconnectTimer.reset()\n//    reconnectTimer.setTimeout() // fires after 1000\n//\n\nvar Timer = (function () {\n  function Timer(callback, timerCalc) {\n    _classCallCheck(this, Timer);\n\n    this.callback = callback;\n    this.timerCalc = timerCalc;\n    this.timer = null;\n    this.tries = 0;\n  }\n\n  _prototypeProperties(Timer, null, {\n    reset: {\n      value: function reset() {\n        this.tries = 0;\n        clearTimeout(this.timer);\n      },\n      writable: true,\n      configurable: true\n    },\n    setTimeout: {\n\n      // Cancels any previous setTimeout and schedules callback\n\n      value: (function (_setTimeout) {\n        var _setTimeoutWrapper = function setTimeout() {\n          return _setTimeout.apply(this, arguments);\n        };\n\n        _setTimeoutWrapper.toString = function () {\n          return _setTimeout.toString();\n        };\n\n        return _setTimeoutWrapper;\n      })(function () {\n        var _this = this;\n\n        clearTimeout(this.timer);\n\n        this.timer = setTimeout(function () {\n          _this.tries = _this.tries + 1;\n          _this.callback();\n        }, this.timerCalc(this.tries + 1));\n      }),\n      writable: true,\n      configurable: true\n    }\n  });\n\n  return Timer;\n})();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n }});\nif(typeof(window) === 'object' && !window.Phoenix){ window.Phoenix = require('phoenix') };","import {Socket} from \"phoenix\"\n\nclass App {\n\n  static init(){\n    var id = Date.now();\n    var players = {};\n    var socket     = new Socket(\"/ws\")\n    socket.connect()\n    socket.onClose( e => console.log(\"CLOSE\", e))\n\n    var chan = socket.chan(\"levels\", {})\n\n    chan.join('levels').receive(\"ignore\", () => console.log(\"auth error\"))\n               .receive(\"ok\", () => logged_player(id))\n               .after(10000, () => console.log(\"Connection interruption\"))\n\n    chan.onError(e => console.log(\"something went wrong\", e))\n    chan.onClose(e => console.log(\"channel closed\", e))\n\n    chan.on(\"logged\", user => {\n      if(id != user.id){\n        add_player(user.id)\n      }\n    })\n\n    chan.on(\"moved\", user => {\n      if(id != user.id){\n        if(players[user.id]){\n          change_position(user.id, user.direction, user.position)\n        }\n        else {\n          add_player(user.id)\n          change_position(user.id, user.direction, user.position)\n        }\n      }\n    })\n\n    chan.on(\"stop\", user => {\n      if(id != user.id){\n        players[user.id].animations.stop();\n        players[user.id].frame = 0;\n      }\n    })\n\n    function logged_player(id){\n      chan.push(\"logged\", {user: id})\n    }\n\n    function add_player(id){\n      var lol = game.add.sprite(32,504, 'dude');\n      game.physics.arcade.enable(lol);\n      lol.body.collideWorldBounds = true;\n\n      lol.animations.add('left', [6, 4, 6, 5], 5, true);\n      lol.animations.add('right', [1, 2, 1, 3], 5, true);\n\n      players[id] = lol\n    }\n\n    function animate(p, direction){\n      p.animations.play(direction);\n    }\n\n    function change_position(id, direction, cord){\n      animate(players[id], direction)\n      players[id].position = cord\n    }\n\n    var game = new Phaser.Game(800, 600, Phaser.AUTO, '', { preload: preload, create: create, update: update });\n    var player  = null\n    var platforms = null\n    var cursors = null\n\n    function preload() {\n        game.load.image('sky', '/images/sky.png');\n        game.load.image('ground', '/images/platform.png');\n        game.load.spritesheet('dude', '/images/spritesheet.png', 32, 32);\n    }\n\n    function create() {\n      game.physics.startSystem(Phaser.Physics.ARCADE);\n      game.add.sprite(0, 0, 'sky');\n\n      platforms = game.add.group();\n      platforms.enableBody = true;\n      var ground = platforms.create(0, game.world.height - 64, 'ground');\n\n      ground.scale.setTo(2, 2);\n      ground.body.immovable = true;\n\n      var ledge = platforms.create(400, 400, 'ground');\n\n      ledge.body.immovable = true;\n      ledge = platforms.create(-150, 250, 'ground');\n      ledge.body.immovable = true;\n\n      player = game.add.sprite(32, game.world.height - 150, 'dude');\n      players[id] = player\n      game.physics.arcade.enable(player);\n\n      player.body.bounce.y = 0.1;\n      player.body.gravity.y = 300;\n      player.body.collideWorldBounds = true;\n\n      player.animations.add('left', [6, 4, 6, 5], 5, true);\n      player.animations.add('right', [1, 2, 1, 3], 5, true);\n    }\n\n    function update() {\n      game.physics.arcade.collide(player, platforms);\n      cursors = game.input.keyboard.createCursorKeys();\n\n      player.body.velocity.x = 0;\n\n      if (cursors.left.isDown)\n      {\n          chan.push(\"moved\", {'id': id, direction:'left', 'cord': player.position})\n          player.body.velocity.x = -100;\n          player.animations.play('left');\n      }\n      else if (cursors.right.isDown)\n      {\n          chan.push(\"moved\", {'id': id, direction:'right', 'cord': player.position})\n          player.body.velocity.x = 100;\n          player.animations.play('right');\n      }\n      else\n      {\n          player.animations.stop();\n          chan.push(\"stop\", {'id': id})\n          player.frame = 0;\n      }\n      if (cursors.up.isDown && player.body.touching.down)\n      {\n          chan.push(\"moved\", {'id': id, 'cord': player.position})\n          player.body.velocity.y = -350;\n      }\n    }\n  }\n}\n\n$( () => App.init() )\n\nexport default App\n"]}